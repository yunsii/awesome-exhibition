import { writeFileSync } from 'node:fs'
import { join } from 'node:path'
import process from 'node:process'

import { toArray } from '@antfu/utils'
import MagicString from 'magic-string'
import { transform } from 'oxc-transform'
import { createUnimport, resolvePreset } from 'unimport'

import type { Arrayable } from '@antfu/utils'
import type { LogLevel } from 'consola'
import type { Import, InlinePreset, Preset } from 'unimport'
import type { LoaderContext } from 'webpack'

import { logger } from './logger'

export type ImportNameAlias = [string, string]

export type ImportsMap = Record<string, (string | ImportNameAlias)[]>

export interface LoaderOptions {
  imports?: Arrayable<Import | ImportsMap | InlinePreset>
  dirs?: string[]
  presets?: Preset[]
  /** emit generated d.ts; true -> `auto-imports.d.ts` or string filename */
  dts?: string | boolean
  /** ref: https://github.com/unjs/consola#log-level */
  logLevel?: LogLevel
}

export async function flattenImports(map: LoaderOptions['imports']): Promise<Import[]> {
  const promises = await Promise.all(toArray(map)
    .map(async (definition) => {
      if ('from' in definition && 'imports' in definition) {
        return await resolvePreset(definition as InlinePreset)
      } else if ('name' in definition && 'from' in definition) {
        // It's an Import object
        return [definition as Import]
      } else {
        const resolved: Import[] = []
        for (const mod of Object.keys(definition)) {
          for (const id of definition[mod]) {
            const meta = {
              from: mod,
            } as Import
            if (Array.isArray(id)) {
              meta.name = id[0]
              meta.as = id[1]
            } else {
              meta.name = id
              meta.as = id
            }
            resolved.push(meta)
          }
        }
        return resolved
      }
    }))

  return promises.flat()
}

// module-level caches to avoid repeating work across files
const emittedDts = new Set<string>()

export default async function loader(this: LoaderContext<LoaderOptions>, source: string) {
  const callback = this.async()
  const options: LoaderOptions = (this.getOptions ? this.getOptions() : {})
  const resource = this.resourcePath

  if (options.logLevel) {
    logger.level = options.logLevel
  }

  try {
    const unimport = createUnimport({
      imports: await flattenImports(options.imports || []),
      dirs: options.dirs || [],
      presets: options.presets || [],
      injectAtEnd: true,
    })

    await unimport.init()

    // optionally emit generated .d.ts once (only if no changes, but to match original, run always)
    if (options.dts) {
      const filename = options.dts === true ? 'auto-imports.d.ts' : String(options.dts)
      if (!emittedDts.has(filename)) {
        const dts = await unimport.generateTypeDeclarations()
        const content = `${[
          '/* eslint-disable */',
          '/* prettier-ignore */',
          '// @ts-nocheck',
          '// noinspection JSUnusedGlobalSymbols',
          '// Generated by unplugin-auto-import',
          '// biome-ignore lint: disable',
          dts,
        ].join('\n')}\n`
        // emitFile is available on loader context in many webpack versions
        if ('emitFile' in this && typeof this.emitFile === 'function') {
          this.emitFile(filename, content)
          logger.info(`Emitted type declarations to ${filename}`)
        } else {
          // fallback: write to process.cwd() for Turbopack compatibility
          const filePath = join(process.cwd(), filename)
          try {
            writeFileSync(filePath, content, 'utf-8')
            logger.info(`Wrote type declarations to ${filePath}`)
          } catch (error) {
            logger.error(`Failed to write ${filePath}:`, error)
          }
        }
        emittedDts.add(filename)
      }
    }

    // Transform JSX/TSX to JS/TS if needed
    let analysisCode = source
    const isJSX = resource.endsWith('.tsx') || resource.endsWith('.jsx')
    if (isJSX) {
      const result = await transform(resource, source, {
        lang: resource.endsWith('.tsx') ? 'tsx' : 'jsx',
        // 仅供分析代码 imports 使用，故不需要完整转换
        jsx: { runtime: 'classic' },
        sourcemap: false, // For simplicity, disable sourcemap for now
      })
      analysisCode = result.code
    }

    let s = new MagicString(analysisCode)

    // core transform: inject imports into the MagicString
    const result = await unimport.injectImports(s, resource)
    s = result.s

    // Extract the injected imports block from the analysis code
    const extractImportsBlock = (code: string): { block: string, start: number, end: number } | null => {
      // Find all import lines (allowing leading whitespace)
      const importRegex = /^\s*import\s.*$/gm
      const matches = Array.from(code.matchAll(importRegex))
      if (matches.length === 0) {
        return null
      }

      // Get the start of the first import and end of the last import
      const start = matches[0].index
      const lastMatch = matches[matches.length - 1]
      const end = lastMatch.index + lastMatch[0].length

      const block = code.slice(start, end)
      return { block, start, end }
    }

    const injectedImports = extractImportsBlock(s.toString())
    const originalImports = extractImportsBlock(source)

    // If there are changes in the imports block, apply to original source
    if (injectedImports && (originalImports || injectedImports.block !== (originalImports?.block || ''))) {
      const finalS = new MagicString(source)
      if (originalImports) {
        finalS.overwrite(originalImports.start, originalImports.end, injectedImports.block)
      } else {
        // No original imports, prepend the injected ones
        finalS.prepend(`${injectedImports.block}\n`)
      }

      logger.info(`Injected imports for ${resource}`)

      const map = finalS.generateMap({ source: resource, includeContent: true, hires: true })
      logger.debug(`Finished processing resource: ${resource}`)

      return callback(null, finalS.toString(), map)
    }

    // if nothing changed, return original content
    return callback(null, source)
  } catch (err) {
    if (err instanceof Error) {
      return callback(err)
    } else {
      return callback(new Error(String(err)))
    }
  }
}
